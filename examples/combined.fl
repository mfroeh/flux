squares(): i64[100] {
    let result: i64[100];
    for (let i = 0; i in [0, 100); i += 1;) -> result[i] = i * i;
    ret result;
}

squaresInplace(arr: i64[100]*): void {
    for (let i = 0; i < 100; i += 1;) -> (*arr)[i] = i * i;
    ret;
}

sum(arr: i64[100]*): i64 {
    let sum: i64 = 0;
    for (let i = 0; i < 100; i += 1;) -> sum += (*arr)[i];
    ret sum;
}

// single line, implicit conversion
add(a: f64, b: i64) => a + b;

main(): i64 {
    let arr: i64[100];
    squaresInplace(&arr);
    
    let a: f64 = 3.1415;

    // type inference
    let b = 23;
    let c = add(a, b);

    // shadowing in same scope
    let c = false;

    // pointers!
    let ptr = &c;
    *ptr = false;

    // nested pointers!
    let ptrptr = & ptr;
    **ptrptr = true;

    // inline functions (that shadow outer scope functions!)
    add(a: f64, b: i64, c: i64) => a + b + c;
    let d = add(1, 2, 3);

    let e = 2;
    // blocks
    {
        // this is an entirely different e
        let e = 5;
        let f = 6;
        let g = e + f;
    }

    // ternary expressions (remember we set c to true through **ptrptr :D)
    let h = c ? 1 : 2;

    // funky inline ternary expr function
    ifElse(c: bool, a: i64, b: i64) => c ? a : b;
    let a = ifElse(true, 22, 11);

    ret sum(&arr);
}